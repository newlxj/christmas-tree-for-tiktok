<!DOCTYPE html>
<!--
============================================================
Christmas Tree for TikTok / æŠ–éŸ³æ‰‹åŠ¿åœ£è¯æ ‘ (ç¦»çº¿ç‰ˆ)
============================================================

è¿™ä¸ªæ–‡ä»¶å°±æ˜¯å®Œæ•´çš„ Demoï¼ˆçº¯é™æ€ HTML + æœ¬åœ°ä¾èµ–ï¼‰ï¼Œå¼€ç®±å³ç”¨ã€‚

å¿«é€Ÿå¼€å§‹ï¼ˆæœ¬åœ°è¿è¡Œï¼‰
1) ç”¨ä»»æ„é™æ€æœåŠ¡å™¨å¯åŠ¨ï¼ˆä¸è¦ç›´æ¥ç”¨ file:// æ‰“å¼€ï¼‰ï¼š
   - Python:  python3 -m http.server 8080
   - Node:    npx serve .
2) æµè§ˆå™¨æ‰“å¼€ï¼š http://localhost:8080/
3) å…è®¸æ‘„åƒå¤´æƒé™ï¼ˆç”¨äºæ‰‹åŠ¿è¯†åˆ«ï¼‰ã€‚

é‡è¦ï¼šæ‘„åƒå¤´æƒé™é™åˆ¶ï¼ˆåŠ¡å¿…é˜…è¯»ï¼‰
- WebRTC/getUserMedia åªèƒ½åœ¨â€œå®‰å…¨ä¸Šä¸‹æ–‡â€ä¸­ä½¿ç”¨ï¼š
  - âœ… https:// åŸŸå
  - âœ… http://localhostï¼ˆæˆ– 127.0.0.1ï¼‰
  - âŒ å…¶å®ƒ http:// åŸŸåï¼ˆä¼šè¢«æµè§ˆå™¨æ‹’ç»ï¼Œæ— æ³•æ‰“å¼€æ‘„åƒå¤´ï¼‰
- å› æ­¤ï¼šçº¿ä¸Šéƒ¨ç½²è¯·ä½¿ç”¨ GitHub Pages / è‡ªæœ‰ HTTPS åŸŸåã€‚

é¡µé¢æŒ‰é’®ä¸å¿«æ·é”®
- ğŸ“· æ·»åŠ ç›¸ç‰‡ï¼šé€‰æ‹©å¤šå¼ å›¾ç‰‡ï¼Œä¼šå˜æˆæ ‘ä¸Šçš„â€œç…§ç‰‡ç²’å­â€ã€‚
- âš™ï¸ é«˜çº§æ¨¡å¼ï¼šæ˜¾ç¤º/éšè—å·¦ä¸Šè§’è°ƒè¯•çª—å£ï¼ˆæ‰‹åŠ¿éª¨éª¼ã€è¾“å…¥ç¥ç¦è¯­ã€éŸ³ä¹æ’­æ”¾ï¼‰ã€‚
- ğŸ”— åˆ†äº«å¥½å‹ï¼šå¤åˆ¶å½“å‰é¡µé¢é“¾æ¥åˆ°å‰ªè´´æ¿ã€‚
- é”®ç›˜ï¼šæŒ‰ H éšè—/æ˜¾ç¤º UIï¼ˆæ ‡é¢˜ + åº•éƒ¨æŒ‰é’®ï¼‰ã€‚

æ‰‹åŠ¿è¯´æ˜ï¼ˆåŸºäº MediaPipe æ‰‹éƒ¨å…³é”®ç‚¹çš„å¯å‘å¼é˜ˆå€¼ï¼‰
- â˜ï¸ ä»…é£ŸæŒ‡ä¼¸å‡ºï¼šéšæœºèšç„¦æ”¾å¤§ä¸€å¼ ç…§ç‰‡ï¼ˆFOCUS æ¨¡å¼ï¼‰
- ğŸ–ï¸ å¼ å¼€æ‰‹æŒï¼šç²’å­æ•£å¼€ï¼ˆSCATTER æ¨¡å¼ï¼‰
- âœŠ æ¡æ‹³ï¼šç²’å­èšæˆåœ£è¯æ ‘ï¼ˆTREE æ¨¡å¼ï¼‰
- ğŸ‘ ç‚¹èµï¼šåˆ‡æ¢é»‘è‰²èƒŒæ™¯ä¸»é¢˜ï¼ˆæš—è‰²ï¼‰
- âœŒï¸ å‰ªåˆ€æ‰‹ï¼šæ˜¾ç¤ºé‡‘è‰²ç¥ç¦æ–‡å­—ï¼ˆé»˜è®¤ â€œMerry Christmasâ€ï¼‰å¹¶è®©èƒŒæ™¯æ•£å¼€
- ğŸ‘Œ OK æ‰‹åŠ¿ï¼šéšè—/æ˜¾ç¤º UIï¼ˆåŒ H é”®ï¼‰

è‡ªå®šä¹‰ç¥ç¦è¯­
- ç‚¹å‡»â€œé«˜çº§æ¨¡å¼â€ï¼Œåœ¨è¾“å…¥æ¡†ä¿®æ”¹æ–‡å­—ï¼ˆæœ€å¤š 20 å­—ç¬¦ï¼‰ï¼Œç”¨äº âœŒï¸ æ‰‹åŠ¿å±•ç¤ºã€‚

èƒŒæ™¯éŸ³ä¹
- ä»£ç é‡Œå¯é…ç½®ï¼šAUDIO_URLS æ•°ç»„ï¼ˆç¤ºä¾‹é‡Œå†™äº† "Last-Christmas.mp3"ï¼Œä½ éœ€è¦è‡ªè¡ŒæŠŠ MP3 æ”¾åˆ°ä»“åº“é‡Œï¼Œæˆ–æ”¹æˆä½ è‡ªå·±çš„æ–‡ä»¶å/URLï¼‰ã€‚
  è‹¥ä¸éœ€è¦éŸ³ä¹ï¼šæŠŠ AUDIO_URLS è®¾ä¸º [] å³å¯ã€‚

ç¦»çº¿/æœ¬åœ°ä¾èµ–
- Three.js ä¸ MediaPipe Tasks Vision éƒ½åœ¨ ./libs/ ä¸‹ï¼ˆæ— éœ€ CDNï¼‰ã€‚
- MediaPipe æ¨¡å‹ä¸ WASMï¼š
  - ./libs/mediapipe/hand_landmarker.task
  - ./libs/mediapipe/wasm/

éƒ¨ç½²åˆ° GitHub Pagesï¼ˆç®€è¿°ï¼‰
- Settings -> Pages -> Deploy from a branch -> é€‰æ‹© main / root
- ç­‰å¾…æ„å»ºå®Œæˆåï¼Œè®¿é—®ï¼šhttps://<user>.github.io/<repo>/
- æ³¨æ„ï¼šGitHub Pages è‡ªå¸¦ HTTPSï¼Œå› æ­¤æ‘„åƒå¤´å¯ç”¨ã€‚

============================================================
-->
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Merry Christmas </title>
    
    <!-- å¯¼å…¥æ˜ å°„ (æœ¬åœ° / ç¦»çº¿) -->
    <script type="importmap">
    {
        "imports": {
            "three": "./libs/three/build/three.module.js",
            "three/addons/": "./libs/three/examples/jsm/",
            "@mediapipe/tasks-vision": "./libs/mediapipe/tasks-vision.js"
        }
    }
    </script>

    <!-- å­—ä½“ï¼šä½¿ç”¨æ ‡å‡†å­—ä½“ä»¥å®ç°ç¦»çº¿å…¼å®¹æ€§ -->
    <style>
        :root {
            --color-gold: #d4af37;
            --color-cream: #fceea7;
            --color-bg: #000000;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--color-bg);
            font-family: 'Times New Roman', serif;
            color: var(--color-cream);
            user-select: none;
            -webkit-user-select: none; /* Safari */
        }

        h1 {
            /* å¦‚æœç¼ºå°‘ Cinzelï¼Œåˆ™å›é€€åˆ° serif */
            font-family: 'Times New Roman', serif;
            font-weight: bold;
            font-size: 56px;
            text-align: center;
            margin-top: 20px;
            position: absolute;
            width: 100%;
            top: 0;
            z-index: 10;
            background: linear-gradient(to bottom, #ffffff, var(--color-gold));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
            pointer-events: none;
            text-transform: uppercase;
            letter-spacing: 5px;
        }

        /* UI å®¹å™¨ */
        #ui-container {
            position: absolute;
            bottom: 40px;
            width: 100%;
            display: flex;
            flex-direction: row; /* æ›´æ”¹ä¸ºè¡Œä»¥è¿›è¡Œæ°´å¹³å¯¹é½ */
            justify-content: center; /* æ°´å¹³å±…ä¸­æŒ‰é’® */
            align-items: center;
            z-index: 20;
            transition: opacity 0.5s ease;
            gap: 15px;
            pointer-events: none; /* å…è®¸ç‚¹å‡»ç©¿é€å®¹å™¨ï¼Œä½†ä¸ºå­å…ƒç´ å¯ç”¨ */
            padding: 0 10px;
            box-sizing: border-box;
        }
        
        #ui-container > * {
            pointer-events: auto; /* ä¸ºæŒ‰é’®/è¾“å…¥é‡æ–°å¯ç”¨æŒ‡é’ˆäº‹ä»¶ */
        }

        .upload-wrapper {
            position: relative;
            overflow: hidden;
            display: flex; /* æ›´æ”¹ä¸º flex ä»¥ä½¿å…¶è¡Œä¸ºä¸å…¶ä»–æŒ‰é’®ä¸€è‡´ */
        }

        .btn-glass {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid var(--color-gold);
            color: var(--color-gold);
            padding: 12px 30px;
            font-family: 'Times New Roman', serif;
            font-size: 14px;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            white-space: nowrap; /* é˜²æ­¢æ–‡å­—æ¢è¡Œ */
        }

        .btn-glass:hover {
            background: rgba(212, 175, 55, 0.2);
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.4);
        }

        .helper-text {
            margin-top: 5px;
            font-size: 12px;
            opacity: 0.6;
            letter-spacing: 1px;
            text-align: center;
            position: absolute; 
            bottom: 10px; 
            width: 100%; 
            z-index: 20; 
            color: var(--color-cream);
        }

        input[type="file"] {
            font-size: 100px;
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            cursor: pointer;
            width: 100%;
            height: 100%;
        }

        /* è°ƒè¯• / æµ‹è¯• UI */
        #debug-container {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 30;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid var(--color-gold);
            padding: 10px;
            border-radius: 8px;
            display: none; /* é»˜è®¤éšè— */
            pointer-events: auto;
            max-width: 90%; /* é˜²æ­¢åœ¨å°å±å¹•ä¸Šæº¢å‡º */
        }
        
        #debug-canvas {
            width: 240px; /* æ›´å¤§ä»¥è·å¾—æ›´å¥½çš„å¯è§æ€§ */
            height: 180px;
            background: #222;
            max-width: 100%;
        }

        #debug-info {
            font-family: monospace;
            color: var(--color-gold);
            margin-top: 5px;
            font-size: 12px;
        }

        /* åŠ è½½å™¨ */
        #loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 0.8s ease;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 2px solid rgba(212, 175, 55, 0.1);
            border-top: 2px solid var(--color-gold);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        .loader-text {
            font-family: 'Times New Roman', serif;
            font-size: 14px;
            letter-spacing: 4px;
            color: var(--color-gold);
            text-transform: uppercase;
            text-align: center;
            padding: 0 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .ui-hidden {
            opacity: 0 !important;
            pointer-events: none !important;
        }

        /* æ‘„åƒå¤´éšè—å…ƒç´  (æº) */
        #webcam-source {
            position: absolute;
            bottom: 0;
            right: 0;
            opacity: 0;
            pointer-events: none;
            width: 1px; 
            height: 1px;
        }

        /* å¾®ä¿¡æç¤ºé®ç½© */
        #wechat-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: var(--color-gold);
        }

        #wechat-overlay p {
            font-size: 18px;
            margin-bottom: 30px;
            padding: 0 20px;
            line-height: 1.5;
        }

        /* å“åº”å¼è°ƒæ•´ */
        @media (max-width: 600px) {
            h1 {
                font-size: 32px;
                letter-spacing: 2px;
                margin-top: 15px;
            }

            #ui-container {
                bottom: 60px; /* æé«˜ä¸€ç‚¹ï¼Œç»™åº•éƒ¨æ–‡å­—ç•™ç©ºé—´ */
                flex-wrap: wrap; /* å…è®¸æ¢è¡Œ */
                gap: 10px;
            }

            .btn-glass {
                padding: 10px 15px;
                font-size: 12px;
                flex: 1 1 auto; /* å…è®¸æŒ‰é’®ç¼©æ”¾ä½†ä¿æŒå¤§å° */
                min-width: 80px; /* æœ€å°å®½åº¦ */
                text-align: center;
            }

            .helper-text {
                font-size: 10px;
                bottom: 10px;
                width: 90%;
                left: 5%;
                line-height: 1.4;
            }
            
            .helper-text span {
                display: block; /* åœ¨å°å±å¹•ä¸Šæ¢è¡Œæ˜¾ç¤ºä½œè€… */
                margin-left: 0 !important;
                margin-top: 2px;
            }

            #debug-container {
                left: 10px;
                top: 60px; /* é¿å¼€æ ‡é¢˜ */
            }
        }
    </style>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div class="loader-text">é­”æ³•æ­£åœ¨è½½å…¥(ç¬¬ä¸€æ¬¡çº¦1åˆ†é’Ÿ)ï¼Œè¯·æ‰“å¼€ä½ çš„æ‘„åƒå¤´....</div>
    </div>

    <!-- å¾®ä¿¡/ç§»åŠ¨ç«¯ æç¤ºé®ç½© -->
    <div id="wechat-overlay">
        <p>ä¸ºäº†è·å¾—æœ€ä½³ä½“éªŒï¼Œè¯·ç‚¹å‡»å³ä¸Šè§’ <b>...</b> <br>é€‰æ‹© <b>"åœ¨æµè§ˆå™¨æ‰“å¼€"</b></p>
        <button id="btn-copy-link-wechat" class="btn-glass">å¤åˆ¶é“¾æ¥</button>
        <p style="font-size: 12px; opacity: 0.7; margin-top: 10px;">å¤åˆ¶é“¾æ¥åï¼Œè¯·ä½¿ç”¨ Chrome/Safari æ‰“å¼€</p>
    </div>

    <h1>åœ£è¯é­”æ³•</h1>

    <!-- è°ƒè¯•è§†å›¾ (å·¦ä¸Šè§’) -->
    <div id="debug-container">
        <canvas id="debug-canvas" width="320" height="240"></canvas>
        <div id="debug-info">ä½ çš„æ‰‹åŠ¿: NONE</div>
        
        <!-- è‡ªå®šä¹‰æ–‡æœ¬è¾“å…¥ -->
        <div style="margin-top: 15px; border-top: 1px solid rgba(212, 175, 55, 0.3); padding-top: 10px;">
            <label style="color: var(--color-gold); font-size: 12px; display: block; margin-bottom: 5px; font-family: 'Times New Roman', serif;">è‡ªå®šä¹‰ç¥ç¦è¯­ (å‰ªåˆ€æ‰‹âœŒï¸å±•ç¤º):</label>
            <input type="text" id="custom-text-input" value="Merry Christmas" maxlength="20" 
                   style="width: 100%; background: rgba(0, 0, 0, 0.5); border: 1px solid var(--color-gold); 
                          color: var(--color-cream); padding: 5px; border-radius: 4px; font-family: 'Times New Roman', serif; box-sizing: border-box; pointer-events: auto;">
        </div>

        <!-- éŸ³é¢‘æ’­æ”¾å™¨æ§åˆ¶ -->
        <div style="margin-top: 15px; border-top: 1px solid rgba(212, 175, 55, 0.3); padding-top: 10px; display: flex; align-items: center; justify-content: space-between;">
            <label style="color: var(--color-gold); font-size: 12px; font-family: 'Times New Roman', serif;">èƒŒæ™¯éŸ³ä¹:</label>
            <button id="btn-audio" style="background: rgba(0, 0, 0, 0.5); border: 1px solid var(--color-gold); color: var(--color-gold); padding: 5px 15px; border-radius: 4px; cursor: pointer; font-family: 'Times New Roman', serif; text-transform: uppercase; pointer-events: auto;">â–¶ æ’­æ”¾</button>
        </div>
    </div>

    <!-- ä¸» UI (åº•éƒ¨) -->
    <div id="ui-container">
        <div class="upload-wrapper">
            <button class="btn-glass">ğŸ“· æ·»åŠ ç›¸ç‰‡</button>
            <input type="file" id="file-input" accept="image/*" multiple>
        </div>
        
        <button id="btn-test" class="btn-glass">âš™ï¸ é«˜çº§æ¨¡å¼</button>
        <button id="btn-share" class="btn-glass">ğŸ”— åˆ†äº«å¥½å‹</button>
    </div>

    <div class="helper-text">
        æ‰‹åŠ¿è¯´æ˜ï¼šâ˜ï¸æ”¾å¤§ç…§ç‰‡ | ğŸ–ï¸æ•£å¼€ | âœŠåœ£è¯æ ‘ | ğŸ‘é»‘è‰²èƒŒæ™¯ | âœŒï¸ç¥ç¦ | æŒ‰â€œHâ€æˆ–OKğŸ‘ŒæŒ‰é’®éšè—
       <span style="margin-left: 40px;">liuxiujun @2025 </span> 
    </div>

    <div id="webcam-source">
        <video id="webcam" autoplay playsinline></video>
    </div>

    <script type="module">
        console.log("Starting Christmas Experience (Offline Mode)...");
        
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // --- é…ç½®ä¸å¸¸é‡ ---
        const CONFIG = {
            colors: {
                gold: 0xd4af37,
                cream: 0xfceea7,
                green: 0x0f4d22,
                red: 0x8a0303,
                blue: 0x0000ff
            },
            particles: {
                mainCount: 1500,
                galaxyCount: 300,
                scatterRadius: 20
            },
            snow: {
                count: 3000, 
                minSize: 0.1,
                maxSize: 0.5,
                fallSpeed: 0.8, 
                range: 35
            }
        };

        const MODES = {
            TREE: 'tree',
            SCATTER: 'scatter',
            FOCUS: 'focus'
        };

        const STATE = {
            mode: MODES.TREE,
            targetMode: MODES.TREE,
            focusTargetIndex: -1,
            rotation: { x: 0, y: 0 }, 
            gestureLock: 0,
            isHandActive: false,
            debugMode: false
        };

        // --- å…¨å±€å˜é‡ ---
        let camera, scene, renderer, composer, controls;
        let particles = [];
        let galaxyParticles = [];
        let galaxyGeometry, galaxySystem;
        let snowGeometry, snowSystem, snowParticles = [];
        let goldenTextSystem; 
        let mainGroup;
        let handLandmarker;
        let video;
        let debugCanvas, debugCtx;
        let lastVideoTime = -1;
        let lastPredictionTime = 0; 
        let clock = new THREE.Clock();
        
        // é»˜è®¤ç…§ç‰‡ç²’å­å¼•ç”¨ï¼Œç”¨äºä¸Šä¼ ååˆ é™¤
        let defaultPhotoParticle = null;

        // --- éŸ³é¢‘å…¨å±€å˜é‡ ---
        // è¯·åœ¨æ­¤å¤„æ·»åŠ ä½ çš„ MP3 URL
        const AUDIO_URLS = [
            "Last-Christmas.mp3"
        ];
        let currentAudioIndex = 0;
        let audioPlayer = new Audio();
        let isAudioPlaying = false;

        // --- åˆå§‹åŒ– ---
        async function init() {
            // å¾®ä¿¡æ£€æµ‹
            checkWeChat();

            // åœºæ™¯è®¾ç½®
            scene = new THREE.Scene();
            
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 200);
            camera.position.set(0, 2, 50);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            renderer.toneMappingExposure = 2.2;
            document.body.appendChild(renderer.domElement);

            // ç¯å¢ƒ
            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;

            // åå¤„ç†
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                0.45, // å¼ºåº¦
                0.4,  // åŠå¾„
                0.7   // é˜ˆå€¼
            );

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // ç¯å…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const internalLight = new THREE.PointLight(0xffaa00, 2, 20);
            internalLight.position.set(0, 5, 0);
            scene.add(internalLight);

            const spotGold = new THREE.SpotLight(CONFIG.colors.gold, 1200);
            spotGold.position.set(30, 40, 40);
            spotGold.angle = Math.PI / 6;
            scene.add(spotGold);

            const spotBlue = new THREE.SpotLight(0x4444ff, 600);
            spotBlue.position.set(-30, 20, -30);
            spotBlue.angle = Math.PI / 4;
            scene.add(spotBlue);

            // ç”¨äºæ—‹è½¬çš„ä¸»ç»„
            mainGroup = new THREE.Group();
            scene.add(mainGroup);

            // æ§åˆ¶
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // å†…å®¹ç”Ÿæˆ
            await createContent();
            
            // UI äº‹ä»¶
            setupUI();

            // åˆ›å»ºé›ªèŠ±
            createSnowSystem();

            // åˆ›å»ºé‡‘è‰²æ–‡å­—ç²’å­ (æ–°åŠŸèƒ½)
            createGoldenText();

            // è®¡ç®—æœºè§†è§‰è®¾ç½®
            await setupComputerVision();

            // å¼€å§‹å¾ªç¯
            document.getElementById('loader').style.opacity = '0';
            setTimeout(() => document.getElementById('loader').remove(), 800);
            
            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function checkWeChat() {
            const ua = navigator.userAgent.toLowerCase();
            const isWeChat = ua.match(/MicroMessenger/i) == "micromessenger";
            
            if (isWeChat) {
                const overlay = document.getElementById('wechat-overlay');
                overlay.style.display = 'flex';
                
                const btnCopy = document.getElementById('btn-copy-link-wechat');
                btnCopy.addEventListener('click', () => {
                    const url = window.location.href;
                    copyToClipboard(url, btnCopy);
                });
            }
        }
        
        function copyToClipboard(text, btnElement) {
            navigator.clipboard.writeText(text).then(() => {
                const originalText = btnElement.innerText;
                btnElement.innerText = "å¤åˆ¶æˆåŠŸï¼";
                setTimeout(() => {
                    btnElement.innerText = originalText;
                }, 2000);
            }).catch(err => {
                console.error('Copy failed', err);
                // å¤‡ç”¨æ–¹æ¡ˆï¼šåˆ›å»ºä¸€ä¸ªè¾“å…¥æ¡†é€‰ä¸­æ–‡æœ¬è®©ç”¨æˆ·å¤åˆ¶
                const input = document.createElement('input');
                input.value = text;
                document.body.appendChild(input);
                input.select();
                try {
                    document.execCommand('copy');
                    const originalText = btnElement.innerText;
                    btnElement.innerText = "å¤åˆ¶æˆåŠŸï¼";
                    setTimeout(() => {
                        btnElement.innerText = originalText;
                    }, 2000);
                } catch (e) {
                    alert("å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶åœ°å€æ é“¾æ¥");
                }
                document.body.removeChild(input);
            });
        }

        // --- é‡‘è‰²æ–‡å­—ç²’å­ç³»ç»Ÿ ---
        function createGoldenText(text = "Merry Christmas") {
            // æ¸…ç†æ—§ç³»ç»Ÿ
            if (goldenTextSystem) {
                scene.remove(goldenTextSystem);
                goldenTextSystem.geometry.dispose();
                goldenTextSystem.material.dispose();
                goldenTextSystem = null;
            }

            const canvas = document.createElement('canvas');
            const estimatedWidth = Math.max(1024, text.length * 60 + 200);
            
            canvas.width = estimatedWidth;
            canvas.height = 256; 
            const ctx = canvas.getContext('2d');
            
            ctx.font = 'bold 80px "Times New Roman", serif';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, estimatedWidth / 2, 128);

            const imageData = ctx.getImageData(0, 0, estimatedWidth, 256);
            const data = imageData.data;
            
            const points = [];
            for (let y = 0; y < 256; y += 4) { 
                for (let x = 0; x < estimatedWidth; x += 4) {
                    const alpha = data[(y * estimatedWidth + x) * 4 + 3];
                    if (alpha > 128) {
                        points.push(new THREE.Vector3(
                            (x - estimatedWidth / 2) * 0.035, 
                            (128 - y) * 0.035, 
                            0
                        ));
                    }
                }
            }

            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            
            const count = points.length;
            const randoms = new Float32Array(count);
            for(let i=0; i<count; i++) randoms[i] = Math.random();
            geometry.setAttribute('random', new THREE.BufferAttribute(randoms, 1));

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    color: { value: new THREE.Color(0xffe066) },
                    time: { value: 0 }
                },
                vertexShader: `
                    attribute float random;
                    uniform float time;
                    varying float vAlpha;
                    void main() {
                        float twinkle = sin(time * 8.0 + random * 10.0);
                        vAlpha = 0.6 + 0.4 * twinkle; 
                        
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = (9.0 * 20.0) / -mvPosition.z;
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform vec3 color;
                    varying float vAlpha;
                    void main() {
                        float r = distance(gl_PointCoord, vec2(0.5, 0.5));
                        if (r > 0.5) discard;
                        
                        float glow = 1.0 - (r * 2.0);
                        glow = pow(glow, 0.8); 
                        gl_FragColor = vec4(color + vec3(0.2), vAlpha * glow); 
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            goldenTextSystem = new THREE.Points(geometry, material);
            goldenTextSystem.position.set(0, 0, 35); 
            
            geometry.computeBoundingBox();
            const box = geometry.boundingBox;
            const textWidth = box.max.x - box.min.x;
            
            const distance = camera.position.z - 35;
            const vFOV = THREE.MathUtils.degToRad(camera.fov);
            const visibleHeight = 2 * Math.tan(vFOV / 2) * distance;
            const visibleWidth = visibleHeight * camera.aspect;
            
            const maxAllowedWidth = visibleWidth * 0.9;

            if (textWidth > maxAllowedWidth) {
                const scale = maxAllowedWidth / textWidth;
                goldenTextSystem.scale.set(scale, scale, scale);
            }

            goldenTextSystem.visible = false; 
            scene.add(goldenTextSystem);
        }

        // --- å†…å®¹ç”Ÿæˆ ---
        async function createContent() {
            const geometries = {
                box: new THREE.BoxGeometry(0.5, 0.5, 0.5),
                sphere: new THREE.SphereGeometry(0.3, 16, 16),
                cane: createCandyCaneGeometry()
            };

            const materials = {
                gold: new THREE.MeshStandardMaterial({ color: CONFIG.colors.gold, roughness: 0.2, metalness: 1.0 }),
                green: new THREE.MeshStandardMaterial({ color: CONFIG.colors.green, roughness: 0.4 }),
                red: new THREE.MeshPhysicalMaterial({ color: CONFIG.colors.red, roughness: 0.2, metalness: 0.1, clearcoat: 1.0 }),
                cane: new THREE.MeshStandardMaterial({ map: createCandyTexture() })
            };

            // åˆ›å»ºç²’å­çš„è¾…åŠ©å‡½æ•°
            function createParticle(type, mat, geo) {
                const mesh = new THREE.Mesh(geo, mat);
                
                // éšæœºåˆ†æ•£ä½ç½®
                const u = Math.random();
                const v = Math.random();
                const theta = 2 * Math.PI * u;
                const phi = Math.acos(2 * v - 1);
                const r = 8 + Math.random() * 12; // 8 åˆ° 20
                
                const scatterPos = new THREE.Vector3(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );

                // åœ£è¯æ ‘ç›®æ ‡ä½ç½® (èºæ—‹)
                const t = Math.random(); 
                const y = 15 - t * 25; 
                const radius = 8 * (1 - (y + 10) / 25); 
                const angle = t * 50 * Math.PI; 
                
                const treePos = new THREE.Vector3(
                    radius * Math.cos(angle) + (Math.random()-0.5),
                    y,
                    radius * Math.sin(angle) + (Math.random()-0.5)
                );

                let originalScale = mesh.scale.clone();
                if (type === 'CANE') {
                    mesh.scale.set(0.2, 0.2, 0.2);
                    originalScale.set(0.2, 0.2, 0.2);
                    mesh.rotation.z = Math.random() * Math.PI;
                }

                const particle = {
                    mesh: mesh,
                    type: type,
                    treePos: treePos,
                    scatterPos: scatterPos,
                    rotationSpeed: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.05,
                        (Math.random() - 0.5) * 0.05,
                        (Math.random() - 0.5) * 0.05
                    ),
                    originalScale: originalScale
                };

                mesh.position.copy(treePos); 
                mainGroup.add(mesh);
                particles.push(particle);
            }

            // 1. è£…é¥°ç²’å­
            for (let i = 0; i < CONFIG.particles.mainCount; i++) {
                const rand = Math.random();
                if (rand < 0.45) createParticle('BOX', Math.random() > 0.5 ? materials.gold : materials.green, geometries.box);
                else if (rand < 0.90) createParticle('SPHERE', Math.random() > 0.3 ? materials.gold : materials.red, geometries.sphere);
                else createParticle('CANE', materials.cane, geometries.cane);
            }

            // 2. é»˜è®¤ç…§ç‰‡ (æ ‡è®°ä¸ºé»˜è®¤)
            const photoTexture = createTextTexture("è¯·æ·»åŠ ä½ çš„ç…§ç‰‡");
            addPhotoToScene(photoTexture, true);

            // 3. æ˜Ÿç³»/æ˜Ÿè¾°ç²’å­
            createGalaxySystem();
        }

        function createGalaxySystem() {
            const count = CONFIG.particles.galaxyCount;
            const posArray = new Float32Array(count * 3);
            const opacityArray = new Float32Array(count);
            
            galaxyGeometry = new THREE.BufferGeometry();
            
            for(let i=0; i<count; i++) {
                resetGalaxyParticle(i, posArray, opacityArray, true);
            }

            galaxyGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            galaxyGeometry.setAttribute('alpha', new THREE.BufferAttribute(opacityArray, 1));

            const shaderMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    color: { value: new THREE.Color(0xffffff) }
                },
                vertexShader: `
                    attribute float alpha;
                    varying float vAlpha;
                    void main() {
                        vAlpha = alpha;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = (4.0 * 20.0) / -mvPosition.z;
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform vec3 color;
                    varying float vAlpha;
                    void main() {
                        float r = distance(gl_PointCoord, vec2(0.5, 0.5));
                        if (r > 0.5) discard;
                        float glow = 1.0 - (r * 2.0);
                        glow = pow(glow, 1.5);
                        gl_FragColor = vec4(color, vAlpha * glow);
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            galaxySystem = new THREE.Points(galaxyGeometry, shaderMaterial);
            scene.add(galaxySystem);

            for(let i=0; i<count; i++) {
                galaxyParticles.push({
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.5,
                        (Math.random() - 0.5) * 0.5,
                        (Math.random() - 0.5) * 0.5
                    ),
                    life: Math.random() * 5.0,
                    maxLife: 2.0 + Math.random() * 3.0
                });
            }
        }

        function resetGalaxyParticle(i, posArray, opacityArray, initial = false) {
            const r = 10 + Math.random() * 20;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            
            posArray[i*3] = r * Math.sin(phi) * Math.cos(theta);
            posArray[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
            posArray[i*3+2] = r * Math.cos(phi);
            
            opacityArray[i] = 0; 
        }

        function updateGalaxy(delta) {
            if (!galaxyGeometry) return;
            const positions = galaxyGeometry.attributes.position.array;
            const alphas = galaxyGeometry.attributes.alpha.array;

            for(let i=0; i<CONFIG.particles.galaxyCount; i++) {
                const p = galaxyParticles[i];
                p.life -= delta;
                positions[i*3] += p.velocity.x * delta;
                positions[i*3+1] += p.velocity.y * delta;
                positions[i*3+2] += p.velocity.z * delta;

                const halfLife = p.maxLife / 2;
                if (p.life > halfLife) {
                    alphas[i] = 1.0 - ((p.life - halfLife) / halfLife); 
                } else {
                    alphas[i] = p.life / halfLife; 
                }

                if (p.life <= 0) {
                    resetGalaxyParticle(i, positions, alphas);
                    p.life = p.maxLife;
                    p.velocity.set(
                        (Math.random() - 0.5) * 0.5,
                        (Math.random() - 0.5) * 0.5,
                        (Math.random() - 0.5) * 0.5
                    );
                }
            }
            galaxyGeometry.attributes.position.needsUpdate = true;
            galaxyGeometry.attributes.alpha.needsUpdate = true;
        }

        function createCandyCaneGeometry() {
            const points = [];
            for(let i=0; i<=5; i++) points.push(new THREE.Vector3(0, i*0.5, 0));
            points.push(new THREE.Vector3(0, 2.8, 0.2));
            points.push(new THREE.Vector3(0, 3.0, 0.6));
            points.push(new THREE.Vector3(0, 2.5, 1.0));
            
            const curve = new THREE.CatmullRomCurve3(points);
            return new THREE.TubeGeometry(curve, 20, 0.1, 8, false);
        }

        function createCandyTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, 64, 64);
            ctx.fillStyle = '#ff0000';
            
            for(let i=-64; i<64; i+=16) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i+8, 0);
                ctx.lineTo(i+72, 64);
                ctx.lineTo(i+64, 64);
                ctx.fill();
            }
            
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(1, 4);
            tex.colorSpace = THREE.SRGBColorSpace;
            return tex;
        }

        function createTextTexture(text) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#fceea7'; 
            ctx.fillRect(0, 0, 512, 512);
            ctx.fillStyle = '#d4af37'; 
            ctx.lineWidth = 20;
            ctx.strokeRect(0, 0, 512, 512);
            
            ctx.fillStyle = '#000000';
            ctx.font = 'bold 60px "Times New Roman"';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 256, 256);

            const tex = new THREE.CanvasTexture(canvas);
            tex.colorSpace = THREE.SRGBColorSpace;
            return tex;
        }

        function addPhotoToScene(texture, isDefault = false) {
            let width = 2;
            let height = 2;
            
            if (texture && texture.image) {
                const ratio = texture.image.width / texture.image.height;
                if (ratio >= 1) {
                    width = 2;
                    height = 2 / ratio;
                } else {
                    height = 2;
                    width = 2 * ratio;
                }
            }

            const frameGeo = new THREE.BoxGeometry(width + 0.2, height + 0.2, 0.2);
            const frameMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.gold, roughness: 0.3 });
            const frame = new THREE.Mesh(frameGeo, frameMat);

            const photoGeo = new THREE.PlaneGeometry(width, height);
            const photoMat = new THREE.MeshBasicMaterial({ map: texture });
            const photo = new THREE.Mesh(photoGeo, photoMat);
            photo.position.z = 0.11;
            frame.add(photo);

            const rand = Math.random();
            const y = (Math.random() - 0.5) * 15;
            const radius = 6 + Math.random() * 4;
            const angle = Math.random() * Math.PI * 2;

            const treePos = new THREE.Vector3(
                radius * Math.cos(angle),
                y,
                radius * Math.sin(angle)
            );

            frame.lookAt(new THREE.Vector3(treePos.x * 2, treePos.y, treePos.z * 2));
            const baseRotation = frame.rotation.clone();

            const particle = {
                mesh: frame,
                photoMesh: photo, // Keep reference to change material color later
                type: 'PHOTO',
                treePos: treePos,
                scatterPos: new THREE.Vector3(
                    (Math.random()-0.5)*30, 
                    (Math.random()-0.5)*30, 
                    (Math.random()-0.5)*30
                ),
                rotationSpeed: new THREE.Vector3(0.01, 0.01, 0.01),
                baseRotation: baseRotation,
                originalScale: new THREE.Vector3(1,1,1),
                isDefault: isDefault // æ ‡è®°
            };
            
            frame.position.copy(treePos);
            mainGroup.add(frame);
            particles.push(particle);
            
            if (isDefault) {
                defaultPhotoParticle = particle;
            }
        }

        // --- é›ªèŠ±ç³»ç»Ÿ ---
        function createSnowSystem() {
            const count = CONFIG.snow.count;
            const posArray = new Float32Array(count * 3);
            const sizeArray = new Float32Array(count);
            
            snowGeometry = new THREE.BufferGeometry();
            
            // åˆå§‹åŒ–ç©ºç²’å­
            for(let i=0; i<count; i++) {
                snowParticles.push({
                    y: 0,
                    startX: 0,
                    startZ: 0,
                    velocitySpeed: 0,
                    swayPhase: 0,
                    swaySpeed: 0
                });
                resetSnowParticle(i, posArray, sizeArray, true);
            }

            snowGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            snowGeometry.setAttribute('size', new THREE.BufferAttribute(sizeArray, 1));

            const snowMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    color: { value: new THREE.Color(0xffffff) }
                },
                vertexShader: `
                    attribute float size;
                    void main() {
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = size * (300.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform vec3 color;
                    void main() {
                        vec2 coord = gl_PointCoord - vec2(0.5);
                        if(length(coord) > 0.5) discard;
                        
                        // æŸ”å’Œè¾¹ç¼˜
                        float r = length(coord) * 2.0;
                        float a = 1.0 - pow(r, 3.0);
                        
                        gl_FragColor = vec4(color, a * 0.8);
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            snowSystem = new THREE.Points(snowGeometry, snowMaterial);
            scene.add(snowSystem);
        }

        function resetSnowParticle(i, posArray, sizeArray, initial = false) {
            const p = snowParticles[i];

            // åˆ†å¸ƒï¼šä¸­å¿ƒé™„è¿‘é›ªèŠ±æ›´å¤š
            const maxR = CONFIG.snow.range;
            const r = maxR * Math.pow(Math.random(), 1.5); // åå‘ 0
            const theta = Math.random() * Math.PI * 2;
            
            p.startX = r * Math.cos(theta);
            p.startZ = r * Math.sin(theta);
            
            // åˆå§‹ Y åˆ†å¸ƒ
            p.y = initial ? (Math.random() - 0.5) * 60 : 30;
            
            // ä¸‹è½å‚æ•°
            p.velocitySpeed = CONFIG.snow.fallSpeed * (0.8 + Math.random() * 0.4); // éšæœºé€Ÿåº¦å˜åŒ–
            p.swayPhase = Math.random() * Math.PI * 2;
            p.swaySpeed = 0.5 + Math.random() * 1.0;

            // å†™å…¥ç¼“å†²åŒº
            posArray[i*3] = p.startX;
            posArray[i*3+1] = p.y;
            posArray[i*3+2] = p.startZ;

            // éšæœºå¤§å°
            if (sizeArray) {
                sizeArray[i] = CONFIG.snow.minSize + Math.random() * (CONFIG.snow.maxSize - CONFIG.snow.minSize);
            }
        }

        function updateSnow(delta) {
            if (!snowGeometry) return;
            const positions = snowGeometry.attributes.position.array;
            const time = clock.getElapsedTime();

            for(let i=0; i<CONFIG.snow.count; i++) {
                const p = snowParticles[i];
                
                // å‘ä¸‹è½
                p.y -= p.velocitySpeed * delta;
                
                // å¦‚æœå¤ªä½åˆ™é‡ç½®
                if (p.y < -30) {
                    resetSnowParticle(i, positions, null, false);
                }

                // æ‘†åŠ¨è¿åŠ¨ (éç´¯ç§¯)
                // ä½ç½® = åŸºå‡† + æ‘†åŠ¨
                const swayX = Math.sin(time * p.swaySpeed + p.swayPhase) * 0.5;
                const swayZ = Math.cos(time * p.swaySpeed + p.swayPhase) * 0.5;

                positions[i*3] = p.startX + swayX;
                positions[i*3+1] = p.y;
                positions[i*3+2] = p.startZ + swayZ;
            }
            snowGeometry.attributes.position.needsUpdate = true;
        }

        // --- UI é€»è¾‘ ---
        function setupUI() {
            const fileInput = document.getElementById('file-input');
            const debugContainer = document.getElementById('debug-container');
            const testBtn = document.getElementById('btn-test');

            // å¤„ç†å¤šä¸ªæ–‡ä»¶
            fileInput.addEventListener('change', (e) => {
                const files = e.target.files;
                if (!files || files.length === 0) return;
                
                // ç§»é™¤é»˜è®¤ç›¸ç‰‡ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                if (defaultPhotoParticle) {
                    mainGroup.remove(defaultPhotoParticle.mesh);
                    if (defaultPhotoParticle.mesh.geometry) defaultPhotoParticle.mesh.geometry.dispose();
                    if (defaultPhotoParticle.mesh.material) defaultPhotoParticle.mesh.material.dispose();
                    
                    const idx = particles.indexOf(defaultPhotoParticle);
                    if (idx > -1) particles.splice(idx, 1);
                    defaultPhotoParticle = null;
                }

                Array.from(files).forEach(f => {
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        new THREE.TextureLoader().load(ev.target.result, (t) => {
                            t.colorSpace = THREE.SRGBColorSpace;
                            addPhotoToScene(t);
                        });
                    };
                    reader.readAsDataURL(f);
                });
            });

            // åˆ‡æ¢è°ƒè¯•è§†å›¾
            testBtn.addEventListener('click', (e) => {
                e.stopPropagation(); // é˜²æ­¢å†’æ³¡è§¦å‘ window çš„ç‚¹å‡»äº‹ä»¶
                STATE.debugMode = !STATE.debugMode;
                debugContainer.style.display = STATE.debugMode ? 'block' : 'none';
            });

            // ç‚¹å‡»å¤–éƒ¨å…³é—­é«˜çº§æ¨¡å¼çª—å£
            window.addEventListener('click', (e) => {
                if (STATE.debugMode && !debugContainer.contains(e.target) && e.target !== testBtn) {
                    STATE.debugMode = false;
                    debugContainer.style.display = 'none';
                }
            });

            // åˆ†äº«æŒ‰é’®é€»è¾‘
            const shareBtn = document.getElementById('btn-share');
            shareBtn.addEventListener('click', () => {
                const url = window.location.href;
                copyToClipboard(url, shareBtn);
            });

            window.addEventListener('keydown', (e) => {
                if (e.key.toLowerCase() === 'h') {
                    const ui = document.getElementById('ui-container');
                    const h1 = document.querySelector('h1');
                    ui.classList.toggle('ui-hidden');
                    h1.classList.toggle('ui-hidden');
                }
            });

            // è‡ªå®šä¹‰æ–‡æœ¬è¾“å…¥ç›‘å¬
            const customInput = document.getElementById('custom-text-input');
            let typingTimer;
            customInput.addEventListener('input', (e) => {
                clearTimeout(typingTimer);
                typingTimer = setTimeout(() => {
                    const val = e.target.value.trim() || "Merry Christmas";
                    createGoldenText(val);
                }, 500);
            });

            // --- éŸ³é¢‘æ§åˆ¶é€»è¾‘ ---
            const btnAudio = document.getElementById('btn-audio');
            
            function playNextTrack() {
                if (AUDIO_URLS.length === 0) return;
                currentAudioIndex = (currentAudioIndex + 1) % AUDIO_URLS.length;
                audioPlayer.src = AUDIO_URLS[currentAudioIndex];
                if (isAudioPlaying) {
                    audioPlayer.play().catch(e => console.error("Play error:", e));
                }
            }

            audioPlayer.addEventListener('ended', playNextTrack);

            btnAudio.addEventListener('click', () => {
                if (AUDIO_URLS.length === 0) {
                    alert("æœªé…ç½®éŸ³ä¹åœ°å€ï¼Œè¯·åœ¨ä»£ç  AUDIO_URLS æ•°ç»„ä¸­æ·»åŠ  MP3 é“¾æ¥ã€‚");
                    return;
                }

                if (!audioPlayer.src || audioPlayer.src === "") {
                     audioPlayer.src = AUDIO_URLS[currentAudioIndex];
                }

                if (isAudioPlaying) {
                    audioPlayer.pause();
                    isAudioPlaying = false;
                    btnAudio.innerText = "â–¶ æ’­æ”¾";
                } else {
                    const playPromise = audioPlayer.play();
                    if (playPromise !== undefined) {
                        playPromise.then(() => {
                            isAudioPlaying = true;
                            btnAudio.innerText = "â¸ æš‚åœ";
                        }).catch(error => {
                            console.error("Playback failed:", error);
                            alert("æ’­æ”¾å¤±è´¥ï¼Œè¯·æ£€æŸ¥éŸ³é¢‘åœ°å€ã€‚");
                        });
                    }
                }
            });
        }

        // --- è®¡ç®—æœºè§†è§‰ (MediaPipe) ---
        async function setupComputerVision() {
            video = document.getElementById('webcam');
            debugCanvas = document.getElementById('debug-canvas');
            debugCtx = debugCanvas.getContext('2d');

            try {
                const vision = await FilesetResolver.forVisionTasks(
                    "./libs/mediapipe/wasm" // WASM çš„æœ¬åœ°è·¯å¾„
                );

                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: `./libs/mediapipe/hand_landmarker.task`, // æ¨¡å‹çš„æœ¬åœ°è·¯å¾„
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 1,
                    minHandDetectionConfidence: 0.6, // æ›´é«˜çš„ç½®ä¿¡åº¦ä»¥å‡å°‘è¯¯æŠ¥
                    minHandPresenceConfidence: 0.6,
                    minTrackingConfidence: 0.6
                });

                if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                    video.srcObject = stream;
                    video.addEventListener("loadeddata", predictWebcam);
                }
            } catch (e) {
                console.error("Vision Init Error:", e);
                // ä»…åœ¨éå¾®ä¿¡ç¯å¢ƒä¸‹æŠ¥é”™ï¼Œå¾®ä¿¡ä¸‹å¦‚æœä¸æ”¯æŒä¼šé™é»˜å¤±è´¥æˆ–ç”±é®ç½©å¤„ç†
                // alert("è½½å…¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ‘„åƒå¤´æ˜¯å¦å¼€å¯.");
            }
        }

        async function predictWebcam() {
            let now = performance.now();
            // ä¼˜åŒ–ï¼šé™åˆ¶æ£€æµ‹é¢‘ç‡ (ä¾‹å¦‚ ~15-20 FPS)
            const minInterval = 50; // æ¯«ç§’

            if (now - lastPredictionTime >= minInterval) {
                lastPredictionTime = now;
                
                if (lastVideoTime !== video.currentTime && handLandmarker) {
                    lastVideoTime = video.currentTime;
                    const results = handLandmarker.detectForVideo(video, now);
                    
                    // è°ƒè¯•ç»˜åˆ¶
                    if (STATE.debugMode) {
                        debugCtx.save();
                        debugCtx.clearRect(0, 0, debugCanvas.width, debugCanvas.height);
                        debugCtx.drawImage(video, 0, 0, debugCanvas.width, debugCanvas.height);
                        if (results.landmarks && results.landmarks.length > 0) {
                            drawLandmarks(debugCtx, results.landmarks[0]);
                        }
                        debugCtx.restore();
                    }

                    if (results.landmarks && results.landmarks.length > 0) {
                        STATE.isHandActive = true;
                        processGestures(results.landmarks[0]);
                    } else {
                        STATE.isHandActive = false;
                        STATE.rotation.x *= 0.95;
                        STATE.rotation.y *= 0.95;
                        updateDebugInfo("æœªæ‰¾åˆ°æ‰‹");
                        
                        // æ²¡æ‰‹æ—¶éšè—æ–‡å­—å¹¶æ¢å¤èƒŒæ™¯
                        if (goldenTextSystem && goldenTextSystem.visible) {
                            goldenTextSystem.visible = false;
                            STATE.mode = MODES.TREE; // æ¢å¤èƒŒæ™¯èšé›†
                        }
                    }
                }
            }
            window.requestAnimationFrame(predictWebcam);
        }

        function drawLandmarks(ctx, landmarks) {
            const connections = [
                [0,1], [1,2], [2,3], [3,4], // Thumb
                [0,5], [5,6], [6,7], [7,8], // Index
                [0,9], [9,10], [10,11], [11,12], // Middle
                [0,13], [13,14], [14,15], [15,16], // Ring
                [0,17], [17,18], [18,19], [19,20], // Pinky
                [5,9], [9,13], [13,17] // Palm
            ];

            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 2;
            
            // ç»˜åˆ¶è¿æ¥
            connections.forEach(con => {
                const start = landmarks[con[0]];
                const end = landmarks[con[1]];
                ctx.beginPath();
                ctx.moveTo(start.x * ctx.canvas.width, start.y * ctx.canvas.height);
                ctx.lineTo(end.x * ctx.canvas.width, end.y * ctx.canvas.height);
                ctx.stroke();
            });

            // ç»˜åˆ¶ç‚¹
            ctx.fillStyle = '#ff0000';
            landmarks.forEach(lm => {
                ctx.beginPath();
                ctx.arc(lm.x * ctx.canvas.width, lm.y * ctx.canvas.height, 3, 0, 2 * Math.PI);
                ctx.fill();
            });
        }

        function updateDebugInfo(gesture) {
            const el = document.getElementById('debug-info');
            if (el) el.innerText = `ä½ çš„æ‰‹åŠ¿: ${gesture}`;
        }

        function setTheme(type) {
            const root = document.querySelector(':root');
            
            if (type === 'light') {
                // 1. CSS èƒŒæ™¯ (ç”¨äº UI é€æ˜æ„Ÿ)
                root.style.setProperty('--color-bg', '#f0f0f0'); 
                
                // 2. Three.js èƒŒæ™¯ (å®é™…å¯è§çš„èƒŒæ™¯)
                const lightColor = new THREE.Color(0xf0f0f0);
                scene.background = lightColor;
                renderer.setClearColor(lightColor);
                
                // 3. é›ªèŠ±é¢œè‰² (ç™½è‰²èƒŒæ™¯ä¸Šçš„é»‘è‰²é›ªèŠ±)
                if (snowSystem) {
                    snowSystem.material.uniforms.color.value.set(0x000000);
                }

                // 4. å¦‚æœæ·»åŠ äº†é›¾ï¼Œæˆ–è€… Bloom é˜ˆå€¼å¯èƒ½éœ€è¦è°ƒæ•´
                // ä½†ç®€å•çš„é¢œè‰²åˆ‡æ¢ç°åœ¨åº”è¯¥å¯è¡Œã€‚

            } else {
                // æš—é»‘æ¨¡å¼
                root.style.setProperty('--color-bg', '#000000');
                
                const darkColor = new THREE.Color(0x000000);
                scene.background = null; // é»˜è®¤ä¸ºæ¸…é™¤/é»‘è‰²
                renderer.setClearColor(darkColor);
                
                if (snowSystem) {
                    snowSystem.material.uniforms.color.value.set(0xffffff);
                }
            }
        }

        function processGestures(landmarks) {
            const wrist = landmarks[0];
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const middleTip = landmarks[12];
            const ringTip = landmarks[16];
            const pinkyTip = landmarks[20];
            const palm = landmarks[9];

            // äº¤äº’æ˜ å°„
            const targetRotY = (0.5 - palm.x) * 3; 
            const targetRotX = (palm.y - 0.5) * 2; 
            STATE.rotation.y += (targetRotY - STATE.rotation.y) * 0.1;
            STATE.rotation.x += (targetRotX - STATE.rotation.x) * 0.1;

            if (STATE.gestureLock > 0) {
                STATE.gestureLock--;
                return;
            }

            // --- æ‰‹åŠ¿é€»è¾‘ ---
            // åˆ°æ‰‹è…•çš„è·ç¦»
            const distThumb = Math.hypot(thumbTip.x - wrist.x, thumbTip.y - wrist.y);
            const distIndex = Math.hypot(indexTip.x - wrist.x, indexTip.y - wrist.y);
            const distMiddle = Math.hypot(middleTip.x - wrist.x, middleTip.y - wrist.y);
            const distRing = Math.hypot(ringTip.x - wrist.x, ringTip.y - wrist.y);
            const distPinky = Math.hypot(pinkyTip.x - wrist.x, pinkyTip.y - wrist.y);
            
            // å¯å‘å¼ (é˜ˆå€¼)
            const OPEN_THRESH = 0.3;
            const CLOSED_THRESH = 0.25;

            const isIndexOpen = distIndex > OPEN_THRESH;
            const isMiddleOpen = distMiddle > OPEN_THRESH;
            const isRingOpen = distRing > OPEN_THRESH;
            const isPinkyOpen = distPinky > OPEN_THRESH;
            
            // æ‹‡æŒ‡å¾ˆç‰¹æ®Šï¼Œæ£€æŸ¥å®ƒæ˜¯å¦è¿œç¦»é£ŸæŒ‡åŸºéƒ¨æˆ–åªæ˜¯é€šç”¨çš„ä¼¸å±•
            const isThumbOpen = distThumb > 0.3; 

            // OK æ‰‹åŠ¿é€»è¾‘: æ‹‡æŒ‡å°–å’Œé£ŸæŒ‡å°–æ¥è§¦ï¼Œå…¶ä»–ä¸‰æŒ‡ä¼¸ç›´
            const distThumbIndex = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
            const isOkGesture = distThumbIndex < 0.1 && isMiddleOpen && isRingOpen && isPinkyOpen;

            if (isOkGesture) {
                const ui = document.getElementById('ui-container');
                const h1 = document.querySelector('h1');
                
                if (!ui.classList.contains('ui-hidden')) {
                    ui.classList.add('ui-hidden');
                    h1.classList.add('ui-hidden');
                    updateDebugInfo("OK (ğŸ‘Œéšè—ç•Œé¢)");
                } else {
                    ui.classList.remove('ui-hidden');
                    h1.classList.remove('ui-hidden');
                    updateDebugInfo("OK (ğŸ‘Œæ˜¾ç¤ºç•Œé¢)");
                }
                
                STATE.gestureLock = 25; // å¢åŠ é”å®šæ—¶é—´ï¼Œé˜²æ­¢è¿ç»­è§¦å‘åˆ‡æ¢
                return;
            }

            // 0. SHAKA (ğŸ¤™ å…­å…­å…­/ç”µè¯): æ‹‡æŒ‡å’Œå°æŒ‡å¼ å¼€ï¼Œä¸­é—´ä¸‰ä¸ªé—­åˆ
            // å®æ—¶æ§åˆ¶æ˜¾ç¤ºï¼Œæ‰‹åŠ¿æ¶ˆå¤±å³æ¶ˆå¤±
            if (isThumbOpen && isPinkyOpen && distIndex < CLOSED_THRESH && distMiddle < CLOSED_THRESH && distRing < CLOSED_THRESH) {
                // updateDebugInfo("666 (ğŸ¤™Merry Christmas)");
                // if (goldenTextSystem) {
                //     goldenTextSystem.visible = true;
                //     // æ–‡å­—æ˜¾ç¤ºæ—¶ï¼ŒèƒŒæ™¯æ•£å¼€ä»¥å‡å°‘å¹²æ‰°
                //     if (STATE.mode !== MODES.SCATTER) STATE.mode = MODES.SCATTER;
                // }
                // // ä¸ä½¿ç”¨ gestureLockï¼Œå› ä¸ºè¿™æ˜¯å®æ—¶/ç¬æ—¶çš„
                // return; // ä¼˜å…ˆè¿”å›ï¼Œé¿å…è§¦å‘å…¶ä»–æ¨¡å¼

                updateDebugInfo("666 (ğŸ¤™ç™½è‰²ä¸»é¢˜)");
                setTheme('light');
                STATE.gestureLock = 10;

            } else {
                if (goldenTextSystem && goldenTextSystem.visible) {
                    goldenTextSystem.visible = false;
                    // æ–‡å­—æ¶ˆå¤±æ—¶ï¼ŒèƒŒæ™¯æ¢å¤èšé›† (å¦‚æœå½“å‰æ˜¯æ•£å¼€çŠ¶æ€)
                    if (STATE.mode === MODES.SCATTER) STATE.mode = MODES.TREE;
                }
            }

            // 1. èƒœåˆ© (å‰ªåˆ€æ‰‹ âœŒï¸)ï¼šé£ŸæŒ‡å’Œä¸­æŒ‡å¼ å¼€ï¼Œæ— åæŒ‡å’Œå°æŒ‡é—­åˆ
            if (isIndexOpen && isMiddleOpen && distRing < CLOSED_THRESH && distPinky < CLOSED_THRESH) {
                // updateDebugInfo("å‰ªåˆ€æ‰‹ (âœŒï¸ç™½è‰²ä¸»é¢˜)");
                // setTheme('light');
                // STATE.gestureLock = 5;
                updateDebugInfo("âœŒï¸ (Merry Christmas)");
                if (goldenTextSystem) {
                    goldenTextSystem.visible = true;
                    // æ–‡å­—æ˜¾ç¤ºæ—¶ï¼ŒèƒŒæ™¯æ•£å¼€ä»¥å‡å°‘å¹²æ‰°
                    if (STATE.mode !== MODES.SCATTER) STATE.mode = MODES.SCATTER;
                     STATE.gestureLock = 20;
                }
                return;
            }

            // 2. ç‚¹èµ (ğŸ‘)ï¼šæ‹‡æŒ‡å¼ å¼€ï¼Œå…¶ä»–é—­åˆ
            if (isThumbOpen && distIndex < CLOSED_THRESH && distMiddle < CLOSED_THRESH && distRing < CLOSED_THRESH && distPinky < CLOSED_THRESH) {
                updateDebugInfo("ç‚¹èµ (ğŸ‘é»‘è‰²ä¸»é¢˜)");
                setTheme('dark');
                STATE.gestureLock = 5;
                // return;
            }

            // 3. æŒ‡å‘ (â˜ï¸)ï¼šé£ŸæŒ‡å¼ å¼€ï¼Œå…¶ä»–é—­åˆ
            if (isIndexOpen && !isMiddleOpen && !isRingOpen && !isPinkyOpen) {
                updateDebugInfo("èšç„¦ (é€‰æ‹©â˜ï¸)");
                if (STATE.mode !== MODES.FOCUS) {
                    STATE.mode = MODES.FOCUS;
                    const photos = particles.filter(p => p.type === 'PHOTO');
                    if (photos.length > 0) {
                        const randomPhoto = photos[Math.floor(Math.random() * photos.length)];
                        STATE.focusTargetIndex = particles.indexOf(randomPhoto);
                    }
                    STATE.gestureLock = 15;
                }
                return;
            } 

            // 4. æ‹³å¤´ (âœŠ)ï¼šå…¨éƒ¨é—­åˆ
            // ä¸¥æ ¼æ£€æŸ¥ï¼šæ‰€æœ‰æ‰‹æŒ‡é—­åˆã€‚ç®€å•çš„æ‹³å¤´æ‹‡æŒ‡å¯ä»¥åœ¨ä»»ä½•ä½ç½®ï¼Œä½†é€šå¸¸ä¹Ÿé—­åˆã€‚
            const isFist = distIndex < CLOSED_THRESH && distMiddle < CLOSED_THRESH && distRing < CLOSED_THRESH && distPinky < CLOSED_THRESH;

            // 5. å¼ å¼€ (ğŸ–ï¸)ï¼šå…¨éƒ¨å¼ å¼€
            const isOpen = isIndexOpen && isMiddleOpen && isRingOpen && isPinkyOpen;

            if (isFist) {
                updateDebugInfo("æ‹³å¤´ (âœŠåœ£è¯æ ‘)");
                if (STATE.mode !== MODES.TREE) {
                    STATE.mode = MODES.TREE;
                    STATE.gestureLock = 18;
                }
                return;
            } else if (isOpen) {
                updateDebugInfo("å¼ å¼€ (ğŸ–ï¸æ•£å¼€)");
                if (STATE.mode !== MODES.SCATTER) {
                    STATE.mode = MODES.SCATTER;
                    STATE.gestureLock = 10;
                }
                return;
            } else {
                 updateDebugInfo("...");
            }
        }

        // --- åŠ¨ç”»å¾ªç¯ ---
        let lastMode = MODES.TREE;

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // æ¨¡å¼åˆ‡æ¢é€»è¾‘
            if (STATE.mode !== lastMode) {
                // é€€å‡ºèšç„¦æ¨¡å¼
                if (lastMode === MODES.FOCUS && STATE.focusTargetIndex !== -1) {
                    const p = particles[STATE.focusTargetIndex];
                    if (p && p.mesh && p.mesh.parent === scene) {
                        mainGroup.attach(p.mesh);
                        if (p.photoMesh) p.photoMesh.material.color.setScalar(1.0); // æ¢å¤äº®åº¦
                    }
                }

                // è¿›å…¥èšç„¦æ¨¡å¼
                if (STATE.mode === MODES.FOCUS && STATE.focusTargetIndex !== -1) {
                    const p = particles[STATE.focusTargetIndex];
                    if (p && p.mesh) {
                        scene.attach(p.mesh);
                        if (p.photoMesh) p.photoMesh.material.color.setScalar(0.4); // é™ä½äº®åº¦é˜²æ­¢è¿‡æ›
                    }
                }
                lastMode = STATE.mode;
            }

            // æ›´æ–°æ–‡å­— Shader æ—¶é—´
            if (goldenTextSystem && goldenTextSystem.visible) {
                goldenTextSystem.material.uniforms.time.value = time;
            }

            if (!STATE.isHandActive) {
                mainGroup.rotation.y += 0.05 * delta;
                mainGroup.rotation.x *= 0.98;
            } else {
                mainGroup.rotation.y += (STATE.rotation.y - mainGroup.rotation.y) * 0.1;
                mainGroup.rotation.x += (STATE.rotation.x - mainGroup.rotation.x) * 0.1;
            }

            particles.forEach((p, idx) => {
                let targetPos = new THREE.Vector3();
                let targetRot = new THREE.Euler();
                let targetScale = p.originalScale.clone();

                if (STATE.mode === MODES.TREE) {
                    targetPos.copy(p.treePos);
                    targetPos.y += Math.sin(time + targetPos.x) * 0.05;
                    
                    if (p.type === 'PHOTO') {
                        p.mesh.rotation.copy(p.baseRotation);
                    } else {
                        p.mesh.rotation.x += p.rotationSpeed.x;
                        p.mesh.rotation.y += p.rotationSpeed.y;
                    }

                } else if (STATE.mode === MODES.SCATTER) {
                    targetPos.copy(p.scatterPos);
                    
                    // å¦‚æœæ˜¾ç¤ºé‡‘è‰²æ–‡å­—ï¼Œè®©èƒŒæ™¯è·‘å¾—æ›´è¿œï¼Œè…¾å‡ºç©ºé—´
                    if (goldenTextSystem && goldenTextSystem.visible) {
                        targetPos.multiplyScalar(5.0); 
                    }

                    p.mesh.rotation.x += p.rotationSpeed.x * 0.5;
                    p.mesh.rotation.y += p.rotationSpeed.y * 0.5;
                    p.mesh.rotation.z += p.rotationSpeed.z * 0.5;

                } else if (STATE.mode === MODES.FOCUS) {
                    if (idx === STATE.focusTargetIndex) {
                        // ç›®æ ‡ç…§ç‰‡å±å¹•ä¸­å¿ƒ (World Space, because attached to Scene)
                        targetPos.set(0, 0, 35); 
                        
                        // å¼ºåˆ¶å®Œç¾çœ‹å‘ç›¸æœº
                        p.mesh.lookAt(camera.position);
                        p.mesh.rotation.z = 0; // é˜²æ­¢æ»šåŠ¨
                        
                        targetScale.multiplyScalar(3.5); // ç¨å¾®è°ƒæ•´ç¼©æ”¾
                    } else {
                        targetPos.copy(p.scatterPos);
                        targetPos.multiplyScalar(1.5);
                    }
                }

                p.mesh.position.lerp(targetPos, 0.05);
                p.mesh.scale.lerp(targetScale, 0.05);
            });

            updateGalaxy(delta);
            updateSnow(delta);

            controls.update();
            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>